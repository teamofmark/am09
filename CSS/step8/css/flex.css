
.flexContainer{
    background-color: #a4a4a4; margin: 10px; padding: 15px; border-radius: 25px;
    display: flex;
}
.flexContainer .flexItem{
    margin: 10px; padding: 20px; color: white; text-align: center; border-radius: 25px; background-color: black;
}
.flexContainer.test{
    width: 48%; display: inline-flex; box-sizing: border-box;
}
/*
     ? flex - 부모요소가 block형태를 띄면서 내부공간을 flex화
    ? inline-flex - 부모요소가 inline-block형태를 띄면서 내부공간을 flex화
*/
.flexContainer.direction{
    flex-direction: column-reverse;
}
/* 
    ? -direction :
    이 속성은 flexContainer의 주축(mainAxis)방향을 설정한다.
    row (ltr), row-reverse(rtl), column(TopToBottom), column-reverse(BottomToTop)
*/
.flexContainer.wrap{
    flex-wrap: wrap-reverse;
}
    /* 
        -wrap : 
        이 속성은 flexContainer의 width보다 flexItem들의 width 합계가 큰 경우 한 줄로 나오게 할 것인지, 여러줄로 나오게 할 것인지 결정.

        nowrap(개행불허. 1행 모두배치. default. flexItem width 가능한 범위까지 자동축소)
        wrap(width 초과시 개행) - item width 설정시 %, max,min px설정 하여 원하는 타이밍 설정필요
        wrap-reverse(개행하되 역배치)
    */

.flexContainer.flow{
    flex-flow: row wrap;
    /* 
        -flow :
        direction , wrap 을 줄여 쓸 수(shorthand)있다.
        <flex-direction> | <flex-wrap>;
        ? Refns 상에서 | (vertical-bar) 의미는 띄어쓰기.
    */
}
.flexContainer.flow .flexItem{
    width: 33.33%; max-width: 500px; min-width: 300px;
}
.flexContainer[class*='justify']{
    background-color: skyblue; padding: 0;
}
.flexContainer[class*='align']{
    background-color: lightpink; padding: 0;
}
.flexContainer[class*='justify'] .flexItem,
.flexContainer[class*='align'] .flexItem{
    margin: 0;
}
.flexContainer.justifyContent{
    justify-content: space-around;
    /* 
        justify-content : 
        flex container의 main axis를 기준으로 flexItem을 수평 정렬한다.
        
        flex-start (flexItem을 좌측 기준정렬)
        flex-end (flexItem을 우측 기준정렬)
        center (flexItem을 가운데 기준정렬)
        space-between (flexItem 중 처음은 좌측기준, 마지막은 우측기준, 나머지는 동일간격으로 정렬)
        space-around (모든 flexItem은 처음,마지막 사이를  동일간격으로 정렬 외 나머지 배치)
        space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.)
    */
}
.flexContainer.alignContent{
    height: 500px;
    flex-wrap: wrap;
    justify-content: space-between;
    align-content: space-between;
    /* 
        align-content
        flexContainer의 crossAxis를 기준으로 flexItem들을 수직정렬 한다.

        ! stretch(flexItem 행간을 균등하게. crossStart(축의시작)에서 End(축의종료)까지 꽉찬높이.) - 기본
        flex-start (flexItem 행 간격 없이 (stack))
        flex-end (flexContainer의 cross end 기준으로 행 간격 없이)
        center (flexContainer의 cross axis 중앙 기준으로 행 간격 없이)
        space-between (첫 행은 flexContainer cross start 기준, 마지막 행은 flexContainer cross end 기준, 나머지 행 균등하게)
        space-around (모든 flexItem은 처음,마지막 사이를  동일간격으로 정렬 외 나머지 배치)
        space-evenly (여유 공간을 flex 항목 사이의 공간 및 시작선 및 끝선과 flex 항목 간의 공간에 모두 균등하게 배분.) 
    */
}
.flexContainer.justifyItems{
    display: grid;
    background-color: yellow;
    max-width: 300px;
    margin: 0 auto;
    justify-items: stretch;
}
.flexContainer.justifyItems:hover{
    justify-items: center;
}
/* 
    ? justify-items:
    * flexItem을 parent Width기준으로 flexContainer의 수평 방향으로 정렬한다.
    * justify-items 속성은 모든 flexitem에 적용된다.

    * stretch (cross Start 에서 End까지 꽉찬 너비)
    * flex-start (cross Start 기준으로 정렬.)
    * flex-end (cross End 기준으로 정렬.)
    * center (flexContainer의 주축 중앙에 정렬.)
*/
.flexContainer.alignItems{
    align-items: center;
    background-color: orange;
}
.flexContainer.alignItems:hover{
    align-items: flex-end;
}
.flexContainer.alignItems .flexItem:first-of-type{
    line-height: 100px;
}
.flexContainer.alignItems .flexItem:nth-of-type(2){
    line-height: 200px;
}
/* 
    ? align-items : 
    * flexItem을 line-height(contentHeight)기준으로 flexContainer의 수직 방향으로 정렬한다.
    * align-items 속성은 모든 flexItem에 적용된다.

    * stretch (cross Start 에서 End까지 꽉찬 높이)
    * flex-start (cross Start 기준으로 정렬.)
    * flex-end (cross End 기준으로 정렬.)
    * center  (flexContainer의 주축 중앙에 정렬.)
    * baseline (안의 컨텐츠 End 기준으로 정렬.)
*/
.flexContainer.justifySelf{
    max-width: 300px; display: grid; margin: 0 auto;
}
.flexContainer.justifySelf .flexItem:first-of-type{
    justify-self: stretch;
}
.flexContainer.justifySelf:hover .flexItem:first-of-type{
    justify-self: center;
}
.flexContainer.justifySelf .flexItem:last-of-type{
    justify-self: flex-end;
}
.flexContainer.justifySelf:hover .flexItem:last-of-type{
    justify-self: flex-start;
}
/* 
    ? justify-self
    * flexItem중 지정된 아이템만 정렬 속성 적용.
    * stretch - 부모공간 기준 자신의 너비 늘려 맞추기.
    * flex-start - 부모공간 기준 자신의 위치를 좌측으로.
    * center -  부모공간 기준 자신의 위치를 중앙으로.
    * flex-end - - 부모공간 기준 자신의 위치를 우측으로. 
*/
.flexContainer.alignSelf .flexItem:first-of-type{
/* todo. align-self 초기값 */
    align-self: center;
}
.flexContainer.alignSelf:hover .flexItem:first-of-type{
/* todo. align-self 변경 값 */
    align-self: flex-end;
}
.flexContainer.alignSelf .flexItem:nth-of-type(2){
    /* todo. 다른 대상들과 다른 높이 */
    line-height: 100px;
}
/* 
    ? align-self:
    flexItem중 지정된 item에만 정렬 속성 적용.
    * stretch - 부모 공간 기준(형제중 가장 큰)으로 자신의 높이를 늘려 맞추기
    * flex-start - 부모 공간 기준(형제중 가장 큰)으로 자신의 위치를 상단으로
    * center - 부모 공간 기준(형제중 가장 큰)으로 자신의 위치를 중앙으로
    * flex-end - 부모 공간 기준(형제중 가장 큰)으로 자신의 위치를 하단으로
*/

.flexContainer.orderItem .flexItem.order1{
    background-color: lightgreen; color: green; font-weight: bold; order: 1;
}
.flexContainer.orderItem .flexItem.order2{
    background-color: lightpink; color: deeppink; font-weight: bold; order: 3;
}
.flexContainer.orderItem .flexItem.order3{
    background-color: lightblue; color: midnightblue; font-weight: bold; order: 0;
}

.flexContainer.flexShortHand{
    width: 50%; margin: 0; padding: 0;
    max-width: 300px;
}
.flexContainer.flexShortHand .flexItem{
    margin: 0; padding: 0; word-break: break-all;
}
.flexContainer.flexShortHand .flexItem:first-child{
    /* 팽창비율
    flex-grow: 2;
    flex-basis: 0;*/
    flex-shrink: 2;
    flex-basis: 150px;
}
.flexContainer.flexShortHand .flexItem:first-child~*{
    /* 팽창비율
    flex-grow: 1;
    flex-basis: 0; */
    flex-shrink: 1;
    flex-basis: 150px;
}
/* 
    ? flex- grow(팽창or확장비) : 
    ! item의 증가비율을 정한다. default: 0. 즉, 빈 공간을 알아서 확장해 채우지 않는다.
    ! 음수 비허용. 양수 입력시 '총 증가 내부팽창지수(growSummary)의 너비중 입력된 비율만큼의 너비를 가진다.
    * example. Item이 3개이고 item들에게 grow가 1이 부여된다면 =? 각각 1/3(33.33%)의 너비를 갖게 된다.
    ? example. 만약 전체 (300px)의 item3개에 개별적으로 grow가 부여된다면?
    * flexItem:first-child{flex-grow:2;} -> 0 + (300/4)*2 = 150.
    todo. basis + (부모너비/총증가내부팽창지수)*팽창비 = 값.
    ! 단, max-width가 설정되면 해당 수치를 넘을 수 없다.
*/
/* 
    ? flex- shrink(수축비):
    ! 기준이 되는 부모가 각 item들의 너비(basis)총합보다 줄어 들 때 수축되는 비율을 정한다. default : 1
    ! 음수 비허용. 양수 입력시 '총 감소 내부수축지수(shrink합산)'의 너비중 입력된 비율만큼 수축될 수 있다.
    ? example. 만약 전체 (300px)의 item3개에 개별적으로 shrink가 부여된다면?
    * flexItem:first-of-type{flex-shrink:2;} 150 - (150/4)*2 = 75.
    todo. basis - (각너비/총감소내부수축지수)*비율 = 감소된 수치.
    ! 단, min-width가 설정되면 해당 수치를 넘을 수 없다.
*/
/* todo shortHand -  flex: [grow] | [shrink] | [basis] */
/* 
    todo.1 flex : none; -> -grow: 0, -shrink:0, -basis: auto; = flex해제
    todo.2 flex: <flex-grow>; -> -shrink:1, -basis: 0; = 팽창비만 가동되는 조건
    todo.3 flex: <flex-basis>; -> -shrink:1, -grow: 1; = 지정된 너비에서 동비로 팽창,수축 모두 가동조건
    todo.4 flex: <flex-grow> <flex-shrink>; -> -basis: 0; = 부모 통제 아래 각 비로 팽창,수축 가동 조건
    todo.5 flex: <flex-grow> <flex-basis>; -> -shrink: 1; = 지정된 너비에서 팽창은 각비로 작동, 수축은 동비로 작동.
*/